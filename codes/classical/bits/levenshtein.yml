#######################################################
## This is a code entry in the error correction zoo. ##
##       https://github.com/errorcorrectionzoo       ##
#######################################################

code_id: levenshtein
physical: bits
logical: bits

name: 'Levenshtein'
introduced: '\cite{manual:{Levenshtein, V. "On the redundancy and delay of decodable coding of natural numbers." Probl. Cybern. 20, 173-179 (1968).}}'

description: 'The Levenshtein code is a prefix code for compressing the binary representation of non-negative integers. The prefix is a representation of the magnitude of the integer. The codewords are strings of bits with variable length.'

# protection: 'This code does not protect against errors.'

features:

  # rate: ''

  encoders: |
    The code of zero is 0. To code a positive number \(n\):
    1) Set the count variable \(C\) to 1. Initialize the codeword as the empty string.
    2) Take the binary representation of \(n\) without its leading 1 and prepend it to the codeword.
    3) Let \(M\) be the number of bits prepended in the previous step.
    4) If \(M\neq 0\), increment \(C\) by 1. Set \(n=M\) and go to step 2.
    5) If \(M=0\), prepend \(C\) 1s followed by a 0 to the codeword and stop.
    \cite{\manual{Salomon, D. Variable-length codes for data compression. Springer, 80 (2007).}}

  # transversal_gates: 'Transversal ... gates \cite{doi:ok-paper}. Comment out if doesn''t apply.'

  # general_gates: ''

  decoders: |
    To decode a codeword:
    1) Set the count \(C\) to the number of consecutive 1s preceding the first 0 in the codeword.
    2) If \(C=0\), the decoded value is 0. Stop.
    3) Set \(N=1\) and repeat step 4 \((C-1)\) times.
    4) Read \(N\) bits, prepend a 1, and assign the resulting string to \(N\). The string \(N\) after the last iteration is the decoded value.
    \cite{\manual{Salomon, D. Variable-length codes for data compression. Springer, 80 (2007).}}

  # fault_tolerance: ''

  # code_capacity_threshold: ''

  # threshold: ''

# realizations: ''

notes: 'For a positive integer \(n\) the length of the code is at most \(2+\frac{5}{2}\lfloor\log_2 n\rfloor\). This length is one bit longer than the Elias omega code of \(n\).

relations:
  parents:
    - code_id: prefix
      detail: 'Prefix codes compress data by encoding an integer as a small number of bits with a prefix encoding the integer's order of magnitude.'
  cousins:
    - code_id: elias
      detail: ''
    - code_id: even-rodeh
      detail: ''
