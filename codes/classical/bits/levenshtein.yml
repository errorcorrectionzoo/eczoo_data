#######################################################
## This is a code entry in the error correction zoo. ##
##       https://github.com/errorcorrectionzoo       ##
#######################################################

# code id, physical, logical are all lower case
code_id: levenshtein
physical: bits
logical: bits

# Code title (SINGULAR) + first reference(s) (optional).
name: 'Levenshtein'
introduced: '\cite{manual:{Levenshtein, V. "On the redundancy and delay of decodable coding of natural numbers." Probl. Cybern. 20, 173-179 (1968).}}'

# Anything applicable to a larger parent set of codes (see below) should go in
# that entry instead of here.
description: 'The Levenshtein code is a prefix code for compressing the binary representation of non-negative integers. The prefix is a representation of the magnitude of the integer. The codewords are strings of bits with variable length.'

# protection: 'This code does not protect against errors.'

# This field starts a list of specific labeled subfields; do not leave it
# empty. If empty, comment out. Also, indentations are important!
features:

  # The fields below relate to specific properties of the code that are worth
  # noting. In some cases (see below), there might be multiple pieces of
  # information associated with a field (e.g., mutliple encoders/decoders,
  # multiple facts about fault tolerance, etc.); in such cases, the field
  # accepts a list of text entries, with one item per piece of information.
  #
  # Any fields below should be omitted if they do not apply.

  # rate: ''

  encoders: |
    The code of zero is 0. To code a positive number \(n\):
    1) Set the count variable \(C\) to 1. Initialize the codeword as the empty string.
    2) Take the binary representation of \(n\) without its leading 1 and prepend it to the codeword.
    3) Let \(M\) be the number of bits prepended in the previous step.
    4) If \(M\neq 0\), increment \(C\) by 1. Set \(n=M\) and go to step 2.
    5) If \(M=0\), prepend \(C\) 1s followed by a 0 to the codeword and stop.
    \cite{\manual{Salomon, D. Variable-length codes for data compression. Springer, 80 (2007).}}

  # transversal_gates: 'Transversal ... gates \cite{doi:ok-paper}. Comment out if doesn''t apply.'

  # general_gates: ''

  decoders: |
    To decode a codeword:
    1) Set the count \(C\) to the number of consecutive 1s preceding the first 0 in the codeword.
    2) If \(C=0\), the decoded value is 0. Stop.
    3) Set \(N=1\) and repeat step 4 \((C-1)\) times.
    4) Read \(N\) bits, prepend a 1, and assign the resulting string to \(N\). The string \(N\) after the last iteration is the decoded value.
    \cite{\manual{Salomon, D. Variable-length codes for data compression. Springer, 80 (2007).}}

  # fault_tolerance: ''

  # code_capacity_threshold: ''

  # threshold: ''

  # Propose a field that you feel is applicable to a large and interesting class of codes
  #some_other_field:
  # - 'detail'

# realizations: ''

notes: 'For a positive integer \(n\) the length of the code is at most \(2+\frac{5}{2}\lfloor\log_2 n\rfloor\). This length is one bit longer than the Elias omega code of \(n\).

relations:
  parents:
    - code_id: prefix
      detail: 'Prefix codes compress data by encoding an integer as a small number of bits with a prefix encoding the integer's order of magnitude.'
  cousins:
    - code_id: elias
      detail: ''
    - code_id: even-rodeh
      detail: ''
