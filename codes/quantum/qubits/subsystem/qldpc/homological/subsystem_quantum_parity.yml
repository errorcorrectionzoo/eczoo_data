#######################################################
## This is a code entry in the error correction zoo. ##
##       https://github.com/errorcorrectionzoo       ##
#######################################################

code_id: subsystem_quantum_parity
physical: qubits
logical: qubits

name: 'Subsystem hypergraph product (SHP) code'
short_name: 'SHP'
# 2002.06257 renamed, this paper often cited afterwards
introduced: '\cite{arxiv:quant-ph/0610088,arxiv:2002.06257}'

alternative_names:
  - 'Subsystem generalized Shor code'
  - 'Bacon-Casaccino subsystem code'

description: |
  A CSS subsystem version of the generalized Shor code that has the same parameters as the subspace version, but requires fewer stabilizer measurements, resulting in a simpler error recovery routine.
  The code can also be thought of as a subsystem version of an HGP code because two such codes reduce to an HGP code upon gauge fixing \cite[Sec. III]{arxiv:2002.06257}.
  The code can be obtained from a generalized Shor code by removing certain stabilizers that do no affect the code distance.

  The \(X\)- and \(Z\)-type gauge generators of this CSS \([[n_1n_2,k_1k_2,\min(d_1,d_2)]]\) code correspond to rows of the following two respective matrices,
  \begin{align}
  \begin{split}
  G_{X}&=H_{1}\otimes I_{n_{2}}\\
  G_{Z}&=I_{n_{1}}\otimes H_{2}~,
  \end{split}
  \end{align}
  where \(H_{1,2}\) are the parity-check matrices of two binary linear codes, \(C_1 = [n_1, k_1, d_1]\) and \(C_2 = [n_2, k_2, d_2]\)
  \cite{arxiv:2002.06257}.


# IN THE CASE BOTH CLASSICAL CODES ARE THE SAME:
# The gauge-group generator matrix blocks, \(G_X\) and \(G_Z\), are constructed using the generator matrix \(G_C\) and parity-check matrix \(H_C\) of a linear binary code \(C\).
# They are of the form
# \begin{align}
# \begin{split}
# G_{X}&=\left(H_{C}\otimes I\right),\\
# G_{Z}&=\left(I\otimes H_{C}\right)~.
# \end{split}
# \end{align}
# The stabilizer generator matrix blocks are of the form
# \begin{align}
# \begin{split}
# H_{X}&=\left(H_{C}\otimes G_{C}\right),\\
# H_{Z}&=\left(G_{C}\otimes H_{C}\right)~.
# \end{split}
# \end{align}


features:
  decoders:
    - 'Efficient decoder \cite{doi:10.1109/ISIT.2009.5205650}.'


# Following the construction outlined in \cite{arxiv:quant-ph/0506023}, this \([[n_1n_2,k_1k_2,\min(d_1,d_2)]]\) code is constructed as follows from two classical linear codes, \(C_1 = [n_1, k_1, d_1]\) and \(C_2 = [n_2, k_2, d_2]\).
# Let \(G_1\) and \(G_2\) (\(H_1\) and \(H_2\)) be the generator (parity-check) matrices for \(C_1\) and \(C_2\), respectively.
# Using the rows of \(H_1\) and \(H_2\), construct stabilizer groups \(\mathsf{S}_{1}=\langle S_{1},\ldots,S_{n_{1}-k_{1}}\rangle\) and \(\mathsf{S}_{2}=\langle T_{1},\ldots,T_{n_{2}-k_{2}}\rangle\), where
# \begin{align}
# \begin{split}
# S_{i}&=\otimes_{j=1}^{n_{1}}Z^{(H_{1})_{ij}}\\
# T_{i}&=\otimes_{j=1}^{n_{2}}X^{(H_{2})_{ij}}~.
# \end{split}
# \end{align}
# Next, consider a square lattice of size \(n \times n\) with a qubit located at each vertex, where \(n = n_1 + n_2\).
# Let \(\mathsf{T}_1\) (\(\mathsf{T}_2\)) be the stabilizer group consisting of \(\mathsf{S}_1\) (\(\mathsf{S}_2\)) operators acting on all columns (rows) of the lattice.
# Then, \(\mathsf{T} = \langle\mathsf{T}_1,\mathsf{T}_2\rangle\) is a non-Abelian group from which we can construct an Abelian invariant subgroup \(\mathsf{S}\).
# This subgroup is generated by \(\mathsf{S}_1\) and \(\mathsf{S}_2\) for all stabilizer codeword combinations in both rows and columns.
# By construction, \(\mathsf{S}\) is a stabilizer with \((n_1 - k_1)k_2\) stabilizer generators (i.e., the tensor product of \(I\) and \(Z\) operators), and  \((n_2 - k_2)k_1\) stabilizer generators (i.e., the tensor product of \(I\) and \(X\) operators).

#  It has considerable advantages over the subspace code when it comes to the complexity of error recovery routine, providing a quadratic savings in the number of stabilizers which need to be measured.

#  so that the stabilizer code of \(\mathsf{S}_1\) corrects \(\lfloor\frac{d_1-1}{2}\rfloor\) bit-flip errors, and that of \(\mathsf{S}_2\) corrects \(\lfloor\frac{d_2-1}{2}\rfloor\) phase-flip errors:

#  The logical \hyperref[topic:pauli]{Pauli group} can be constructed using the logical operators of \(\mathsf{S}_1\) and \(\mathsf{S}_2\).

# protection: 'Detecting single-qubit errors of weight up to \(\min(d_1,d_2)\).'


relations:
  parents:
    - code_id: subsystem_lifted_product
      detail: 'SLP codes reduce to SHP codes when the lift is trivial.'
    - code_id: subsystem_product
      detail: 'SP codes reduce to SHP codes when constructed from two classical codes instead of quantum CSS codes \cite{arxiv:2007.12152}.'
  cousins:
    - code_id: hypergraph_product
      detail: 'Two SHP codes can be gauge-fixed to yield an HGP code \cite[Sec. III]{arxiv:2002.06257}.
      The SHP and HGP code constructions yield the same dimension and minimum distance, but the former does not yield QLDPC codes; see \cite[pg. 18]{arxiv:0903.0566}.'
    - code_id: generalized_shor
      detail: 'In a \([[n_1n_2, k_1k_2, min(d_1, d_2)]]\) generalized Shor code, error correction is achieved by measuring \((n_1−k_1)n_2+(n_2−k_2)\) stabilizer generators \cite{arxiv:quant-ph/0508131}.
      The SHP code achieves the same degree of correctability, but requires only \((n_1−k_1)k_2+k_1(n_2−k_2)\) stabilizer measurements.'
    # - code_id: bravyi_bacon_shor
    #   detail: 'SHP and BBS codes have been numerically compared \cite{arxiv:2002.06257}.'
    - code_id: oecc
      detail: 'Classical information can also be encoded in subsystem codes using their gauge qubits \cite{doi:10.1142/S0219749921500416}.'


# Begin Entry Meta Information
_meta:
  # Change log - most recent first
  changelog:
    - user_id: VictorVAlbert
      date: '2023-11-14'
    - user_id: SarahMengLi
      date: '2022-02-21'
    - user_id: VictorVAlbert
      date: '2022-02-21'
