#######################################################
## This is a code entry in the error correction zoo. ##
##       https://github.com/errorcorrectionzoo       ##
#######################################################

code_id: qubit_stabilizer
physical: qubits
logical: qubits

name: 'Qubit stabilizer code'
introduced: '\cite{arxiv:quant-ph/9605005,arxiv:quant-ph/9705052}'

alternative_names:
  - 'Binary stabilizer code'
  - 'Pauli stabilizer code'
  - 'Symplectic code'
  - 'Additive quantum code'
  - 'Additive CWS code'
  - 'Clifford code'
# https://arxiv.org/pdf/2406.12083

description: |
  An \(((n,2^k,d))\) qubit stabilizer code is denoted as \([[n,k]]\) or \([[n,k,d]]\), where \(d\) is the code's distance.
  Logical subspace is the joint eigenspace of commuting Pauli operators forming the code's stabilizer group \(\mathsf{S}\).
  Traditionally, the logical subspace is the joint \(+1\) eigenspace of a set of \(2^{n-k}\) commuting Pauli operators which do not contain \(-I\).
  The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.

  Qubit stabilizer codes form the joint \(+1\)-eigenspace of a stabilizer group \(\mathsf{S}\), i.e., a group of commuting Paulis that does not contain the identity and is generated by \(r=n-k\) generators.
  The table below summarizes the relevant groups and their sizes for a qubit stabilizer code.
    \begin{table}
      \begin{cells}
      \celldata<c H, c H, c H>{purpose & symbol & size}
      \celldata<c, c, c>{
      stabilizer group & \(\mathsf{S}\) & \(2^{n-k}\)
          \\
      code-preserving Paulis & \(\mathsf{N}(\mathsf{S})\) & \(4\cdot 2^{n+k}\)
          \\
      logical Paulis & \(\mathsf{N}(\mathsf{S})/\mathsf{S}\) & \(4^{k}\)
      }
      \end{cells}
      \caption{Groups relevant to qubit stabilizer codes. The normalizer \(\mathsf{N}(\mathsf{S})\) (technically, the centralizer, but these are equivalent for this case) is the group formed by all elements of the \(n\)-qubit Pauli group that commute with all elements in \(\mathsf{S}\). The normalizer is defined so as to include \(i\) and its powers as elements, while the stabilizer group is not.}
      \label{table:stabilizer-groups}
    \end{table}

  Two qubit stabilizer codes codes are \textit{equivalent} if the codespace of one code can be mapped into that of the other under a tensor product of elements of the \hyperref[topic:clifford]{single-qubit Clifford group} and a qubit permutation (see Refs. \cite{arxiv:quant-ph/9608006,arxiv:2501.17447}).
  Equivalence under single-qubit Clifford operations is not the same as equivalence under a tensor product of arbitrary single-qubit unitary operations \cite{arxiv:0709.1266} (see also Ref. \cite{arxiv:0707.4000} about this false LC-LU conjecture).
  Any qubit stabilizer code is equivalent to a graph quantum code via a single-qubit \hyperref[topic:clifford]{Clifford circuit} \cite{arxiv:quant-ph/0111080} (see also \cite{arxiv:quant-ph/0308151,arxiv:quant-ph/0703112}).
  There are algorithms that determine whether two stabilizer states are equivalent that work by checking whether their corresponding cluster states are equivalent \cite{arxiv:1805.05305,arxiv:1805.05306,arxiv:1805.04559}.

  A qubit stabilizer code is \textit{decomposable} if there exists a permutation that maps the stabilizer group into a tensor product of two stabilizer groups acting on disjoint sets of qubits.
  Otherwise, the code is indecomposable.

  \subsection{Code representations}

  Instead of being represented by a basis of codewords, stabilizer codes can be concisely defined and represented by a presentation of the generators of the stabilizer group.  
  Stabilizer generators can be arranged as rows of a matrix, forming a \textit{stabilizer tableau}. 
  A set of generators is not unique, and various stabilizer codes admit generators with certain locality properties.

  For example, a stabilizer tableau of a two-qubit Bell-state stabilizer state is \(\left[\begin{smallmatrix}Z & Z\\ X & X \end{smallmatrix}\right]\).
  Another tableau can be defined by letting \(X \to Y\). 

  Pauli strings, and the corresponding stabilizer tableaus, can be represented in other ways.

  \begin{defterm}{Symplectic representation}
  \label{topic:binary-symplectic-representation}
  In the symplectic representation, the single-qubit identity, \(X\), \(Y\), or \(Z\) Pauli matrices represented using two bits as \((0|0)\), \((1|0)\), \((1|1)\), and \((0|1)\), respectively.
  In other words, the single-qubit Pauli string \(X^a Z^b\) is converted to the vector \(a|b\).
  The multi-qubit version follows naturally.
  \end{defterm}

  Each stabilizer code can be represented by a \((n-k) \times 2n\) \textit{check matrix} (a.k.a. \textit{stabilizer generator matrix}) \(H=(A|B)\), where each row \((a|b)\) is the \hyperref[topic:binary-symplectic-representation]{symplectic representation} of an element from a set of generating elements of the stabilizer group.
  The check matrix can be brought into standard form (a.k.a. canonical form) via Gaussian elimination \cite{doi:10.1017/CBO9780511976667,arxiv:2408.15202}.

  A pair of \(n\)-qubit stabilizers with \hyperref[topic:binary-symplectic-representation]{symplectic representation} \((a|b)\) and \((a^{\prime}|b^{\prime})\) commute iff their symplectic inner product is zero,
  \begin{align}
    a \cdot b^{\prime} + a^{\prime}\cdot b = \sum_{j=1}^{n} a_j b^{\prime}_j + a^{\prime}_i b_i = 0~.
  \end{align}
  The set of all binary symplectic vectors form a symplectic self-orthogonal binary linear code of length \(2n\).

  Another correspondence between qubit Pauli matrices and elements of the \hyperref[topic:finite-fields]{quaternary Galois field} \(\mathbb{F}_4\) yields the one-to-one correspondence between qubit stabilizer codes and trace-Hermitian self-orthogonal additive quaternary codes.

  \begin{defterm}{\(\mathbb{F}_4\) representation}
  \label{topic:gf4-representation}
  An \(n\)-qubit Pauli stabilizer can be represented as a length-\(n\) quaternary vector using the one-to-one correspondence between the four Pauli matrices \(\{I,X,Y,Z\}\) and the four elements \(\{0,1,\omega^2,\omega\}\) of the \hyperref[topic:finite-fields]{quaternary Galois field} \(\mathbb{F}_4\).
  \end{defterm}

  The sets of \(\mathbb{F}_4\)-represented vectors for all generators yield a trace-Hermitian self-orthogonal additive quaternary code.
  This classical code corresponds to the stabilizer group \(\mathsf{S}\) while its trace-Hermitian dual corresponds to the normalizer \(\mathsf{N(S)}\).
  In the case of stabilizer states, the correspondence is between such states and trace-Hermitian self-dual quaternary codes; such codes, and therefore such states, have been classified up to equivalence for \(n \leq 12\) \cite{arxiv:quant-ph/0503236,arxiv:math/0504522}.
  There is a complete set of invariants characterizing stabilizer states up to equivalence \cite{arxiv:quant-ph/0410165,arxiv:quant-ph/0404106}.

  ZX calculus is complete, sound, and universal for qubit stabilizer codes \cite{arxiv:1307.7025}.
  Any stabilizer code can be represented by a \textit{ZX canonical form} (ZXCF) \cite{arxiv:2411.14448}, and there exist two other representations \cite{arxiv:2205.02009,arxiv:2411.14448} that utilize ZX calculus.
  \begin{defterm}{Encoder-respecting form}
  \label{topic:encoder-respecting}
  In an \textit{encoder-respecting form}, each qubit stabilizer code \cite{arxiv:2411.14448} (see also Ref. \cite{arxiv:2109.10210}) is represented by a semi-bipartite graph with \(k\) input and \(n\) output nodes in which the \(k\) input nodes are not connected to each other.
  Conversion between stabilizer tableaus and graphs is achieved using ZX calculus and takes time that is polynomial in \(n\). 
  Properties of the underlying graph are related to properties of the code \cite{arxiv:2411.14448}.
  \end{defterm}

  Qubit stabilizer states can be expressed in terms of linear and quadratic functions over \(\mathbb{Z}_2^n\) \cite{arxiv:quant-ph/0304125,arxiv:quant-ph/0408190,arxiv:0811.0898}.
  There are efficient ways to compute their inner products and other functions \cite{arxiv:1711.07848}.
  The overlap between a stabilizer state and any \(n\)-qubit product state is at most \(2/2^d\) \cite[Thm. 2]{arxiv:2405.01332}.
  Alternative representations include the \textit{decoupling representation}, in which Pauli strings are represented as vectors over \(\mathbb{F}_2\) using three bits \cite{arxiv:2305.17505}.


# More technically, let \(\phi\) be a bijection from a linear binary subspace to \(\mathbb{F}_4^n\). Let \(C\) be a trace-Hermitian self-orthogonal additive subcode over \(\mathbb{F}_4\), containing \(2^{n-k}\) vectors, such that there are no vectors of weight less than \(d\) in \(C^{\perp}\setminus C\). Then, any eigenspace of the inverse map \(\phi^{-1}(C)\) is an \([[n, k, d]]\) stabilizer code over \(\mathbb{F}_4\).


protection: |
  Detects errors on up to \(d-1\) qubits, and corrects erasure errors on up to \(d-1\) qubits.
  There are algorithms to calculate the minimum distance \cite{arxiv:2109.11996,arxiv:2308.15140,arxiv:2408.10743,arxiv:2409.13017}.
  Computing the distance exactly or approximately is generally \(NP\)-complete, and is \(NP\)-hard for \hyperref[topic:degeneracy]{non-degenerate} codes \cite{arxiv:2203.04262}.
  Distance approximation and stabilizer \hyperref[topic:weight-reduction]{weight reduction} are approximately optimal strategies for various quantum lights-out (QLO) games that can be played on the codes' \hyperref[topic:encoder-respecting]{encoder-respecting form} \cite{arxiv:2411.14448}.

  There is the following analogue of the \term{Knill-Laflamme conditions} for qubit stabilizer codes.
  Define the normalizer \(\mathsf{N(S)}\) of \(\mathsf{S}\) to be the set of all Pauli operators that commute with all \(S\in\mathsf{S}\).
  A stabilizer code can correct a Pauli error set \({\mathcal{E}}\) if and only if \(E^\dagger F \notin \mathsf{N(S)}\setminus \mathsf{S}\) for all \(E,F \in {\mathcal{E}}\).

  There are subtleties with defining \hyperref[topic:degeneracy]{degeneracy} for non-stabilizer qubit codes with even distance \cite{preset:GottesmanBook}, but they are resolved for stabilizer codes.
  A stabilizer code is a \hyperref[topic:degeneracy]{degenerate} with respect to \(\mathcal{E}\) if and only if \(E^\dagger F \in \mathsf{N(S)}\) for some Pauli strings \(E,F \in \mathcal{E}\).
  As a distance-\(d\) code, a stabilizer code is degenerate if it admits a non-identity stabilizer whose weight is lower than the distance \cite{preset:GottesmanBook}.
  Since that stabilizer is in the normalizer, a stabilizer code is \hyperref[topic:degeneracy]{degenerate} if and only if it is \hyperref[topic:quantum-weight-enumerator]{impure}.
  The \hyperref[topic:quantum-weight-enumerator]{pure distance} of a qubit stabilizer code is the minimum weight of a non-identity stabilizer, and a qubit stabilizer code is pure if the weight of the lowest-weight stabilizer is the code distance. 
  There is a toolkit for studying \hyperref[topic:degeneracy]{degenerate} codes for Pauli channels \cite{arxiv:quant-ph/0604107}.
  The \hyperref[topic:quantum-gv-bound]{quantum GV bound} can be extended into a three-way tradeoff between distance, rate, and stabilizer weight of a qubit stabilizer code \cite{arxiv:2411.14448}.  

  \begin{defterm}{Cleaning lemma}
  \label{topic:cleaning-lemma}
  If all logical operators act trivially on some subset of qubits in a stabilizer code, then any logical Pauli operator can be represented on the complementary qubit subset via a stabilizer.
  More technically, given any subset \(M\) of qubits that is correctable (under erasure), any logical Pauli operator \(P\) can be \textit{cleaned off} of \(M\) using a stabilizer \(S\) such that \(PS\) is supported on \(M^{\perp}\).
  More generally, for any \(M\), we have \(g(M)+g(M^{\perp}) = 2k\), where \(g(M)\) is the number of logical-\(X\) and logical-\(Z\) Pauli operators supported fully on \(M\) (up to stabilizers).
  The Cleaning Lemma was originally proven \cite{arxiv:0810.1983}, where an analogous result is states for subsystem codes; see also Ref. \cite{arxiv:2204.04699}.
  \end{defterm}

  Qubit stabilizer codes can be interleaved to protect against burst errors \cite{arxiv:quant-ph/0002020}.
  Entropic conditions have been formulated for random projective measurement noise \cite{arxiv:2402.00145}.
  An effective logical channel can be derived for qubit stabilizer codes under Pauli noise \cite{arxiv:2509.16887,arxiv:2601.15505}.



# A stabilizer code is \textit{geometrically local} if the support of the stabilizer generators is bounded by a ball of size independent of \(n\).

features:
  rate: 'The \textit{hashing bound} states that there is a qubit stabilizer code achieving a rate \(R = 1 - H(\mathbf{p})\) for a Pauli noise channel with Pauli error probabilities \(\mathbf{p}=(p_I,p_X,p_Y,p_Z)\), where \(H(\mathbf{p})\) is the entropy of the argument \cite[Thm. 23.6.2]{doi:10.1017/CBO9781139525343}. Finite block length bounds and a refinement of the hashing bound have been developed \cite{arxiv:2408.15202}.'
  encoders:
    - |
      \hyperref[topic:clifford]{Clifford circuits}, i.e., those consisting of CNOT, Hadamard, and certain phase gates \cite{arxiv:quant-ph/9607030}, using an algorithm \cite{arxiv:2301.02356} based on the Gottesman-Knill theorem \cite{arxiv:quant-ph/0406196} or using ZX calculus \cite{doi:10.1007/978-3-540-70583-3_25,arxiv:0906.4725}. Encoding circuits can be done in linear depth, up to logarithmic corrections, for most practical use cases \cite{arxiv:2201.05215}. 
      \begin{defterm}{Destabilizers}
      \label{topic:destabilizers}
      A Clifford encoding circuit maps the first \(r = n-k\) qubits to the logical qubits of the code, and the Pauli \(Z\) operators of those first \(r\) qubits are mapped into a set of stabilizer generators. 
      The set of Pauli \(X\) operators of the first \(r\) qubits that are mapped into a set of generators for the destabilizer group \cite{arxiv:quant-ph/0406196,manual:{Yoder, Theodore J. "A generalization of the stabilizer formalism for simulating arbitrary quantum circuits." See https://www. scottaaronson. com/showcase2/report/ted-yoder. pdf (2012).}}.
      Each such generator anticommutes with only one stabilizer generator while commuting with the rest of the stabilizer generators.
      \end{defterm}

    - 'Circuits obtained by first constructing the CWS form of the code \cite{arxiv:0803.3232,arxiv:0708.1021}. These consist of \(n\) Hadamard gates, a classical encoder which takes at most \(n\) CX gates for a single-qubit encoding code, and at most \(n(n-1)/2\) CZ gates to create the needed graph state.'
    - 'Lindbladian-based dissipative encoding \cite{arxiv:quant-ph/9707049,arxiv:1310.1036}, for which codespace is steady-state space of a Lindbladian. This does not give a speedup, in terms of scaling with \(n\), over circuit-based encoders \cite{arxiv:1310.1037}. A finite-time non-Lindbladian dissipative encoder may always be constructed \cite{arxiv:2102.04531}.'
    - 'Algorithm for fault-tolerant magic-state initialization \cite{arxiv:2501.10291}.'
    - 'Measurement-based purification protocol yielding arbitrary logical states form initial thermal states \cite{arxiv:2502.01393}.'
    - 'State injection protocols that generalize lattice surgery for the surface code \cite{arxiv:2505.10403}.'

  transversal_gates:
    - 'All stabilizer codes realize Pauli transformations transversally; for a single logical qubit, these realize a dicyclic subgroup of \(SU(2)\).
    Several algorithms exist for finding logical Pauli operators \cite{arxiv:quant-ph/9705052,arxiv:0903.5256,arxiv:1803.06987}.'
    - 'The four-block transversal gate mapping each \(X \to IXXX\) and each \(Z \to IZZZ\) implements the same logical gate on all qubits \cite[Exam. 1]{arxiv:quant-ph/9703048}\cite{arxiv:quant-ph/9705052}.'
    - 'Transversal logical gates are in a finite level of the \term{Clifford hierarchy}, which is shown using stabilizer \textit{disjointness} \cite{arxiv:1710.07256} (see also \cite{arxiv:0706.1382,arxiv:1409.8320}).
    Transversal gates for \(n\in\{1,2\}\) are semi-Clifford \cite{arxiv:0712.2084}.'
    - 'No stabilizer code can implement a classical universal gate set transversally \cite{arxiv:1704.07798}.'
    - 'Fold-transversal gates have been extended from qubit CSS codes to qubit stabilizer codes, and there is an algorithm to determine them from the stabilizer group \cite{arxiv:2409.18175}.'
    - 'Computation can be sped up substantially for codes that admit transversal measurements of logical \(X\) and \(Z\) \cite{arxiv:1210.4626}.'
    - 'Diagonal transversal \hyperref[topic:clifford]{Clifford gates} on multiple code blocks must be one of six distinct families of matrix groups, with four of these groups corresponding to Hermitian qubit codes, self-dual CSS codes, non-self-dual CSS codes, and self-dual non-CSS codes \cite{arxiv:2507.10519}. Only two of these cases admit transversal entangling two-qubit gates, the case of the transversal inter-block CNOT gate for a CSS code and/or the case of a transversal interblock \(CZ\) gate for a (not necessarily CSS) \textit{self-dual qubit stabilizer code} \cite{arxiv:2507.10519}.'

  general_gates:
    - 'Logical \hyperref[topic:clifford]{Clifford gates} can be performed by physical \hyperref[topic:clifford]{Clifford circuits} that permute logical Pauli operators \cite{arxiv:1803.06987}.'
    - 'With pieceable fault-tolerance, any \hyperref[topic:degeneracy]{non-degenerate} stabilizer code with a complete set of fault-tolerant single-qubit gates in the \hyperref[topic:clifford]{Clifford group} has a universal set of non-transversal fault-tolerant gates \cite{arxiv:1603.03948}.'
    - 'Non-Clifford gates can be done using \textit{gate teleportation}, in which a gate can be obtained from a particular \textit{magic state} (a.k.a. resource state) \cite{arxiv:quant-ph/9908010,arxiv:quant-ph/0002039}. Such protocols can be made fault tolerant with the help of magic-state distillation \cite{arxiv:quant-ph/0403025,arxiv:quant-ph/0410199}. There exist various performance metrics for magic-state distillation \cite{arxiv:quant-ph/9806094,arxiv:1807.10296,arxiv:1901.03322,arxiv:1904.01124} focusing mostly on distilling \(T\) gates. This Clifford+T gate set is self-testable \cite{arxiv:quant-ph/9904108}. Gate errors in magic-state distillation protocols can sometimes add up destructively \cite{arxiv:1612.01011}. The Hadamard gate cannot be obtained from a magic state \cite{arxiv:2312.03515}. A magic state arising from a generalized controlled \(Z\) gate is a type of hypergraph state \cite{arxiv:1211.5554,arxiv:1404.6492,arxiv:1410.3904} (see \cite{arxiv:2310.16982,arxiv:2404.19005}). The Toffoli gate can be distilled from a particular two-qubit state \cite{arxiv:quant-ph/9905027}. Magic-state protocol fidelity is upper bounded by the fidelity of protocols that have undergone stabilizer reduction, and there exist non-distillable states outside of the stabilizer octahedron \cite{arxiv:0908.0836,arxiv:0908.0838}.'
    - 'Certain operations can be implemented in a fault-tolerant version \cite{arxiv:0806.0875,arxiv:0812.4682,arxiv:0904.2143,arxiv:1312.0165} of holonomic quantum computation \cite{arxiv:quant-ph/9904011}.'
    - 'Magic-state distillation and circuit compilation based on the SWAP test \cite{arxiv:1403.5280}.'
    - 'Logical Clifford synthesis (LCS) taking in a code and a logical Clifford operation and producing a circuit acting on the physical qubits \cite{arxiv:1907.00310}.'
    - 'Clifford stabilizer circuits can be compiled using tableau manipulation \cite{arxiv:2404.19408}.'
    - 'A teleported version of the CPC construction, the Clifford noise reduction (CliNR) scheme, can reduce noise in \hyperref[topic:clifford]{Clifford circuits} with Pauli measurements with at most a three-fold overhead in the number of qubits and gates \cite{arxiv:2407.06583,arXiv:2504.13356}. There is a simple formula for the probability that a \hyperref[topic:clifford]{Clifford circuit} contains a logical error \cite{arxiv:2009.07752}.'
    - 'Logical Trotter circuits for any stabilizer code can be implemented via symplectic transvections \cite{arxiv:2504.11444}.'
    - 'Hardware-tailored logical \hyperref[topic:clifford]{Clifford circuits} \cite{arxiv:2505.20261}.'
    - 'The \hyperref[topic:bk-bound]{Bravyi-Koenig bound} can be generalized to arbitrary qubit stabilizer codes \cite{arxiv:2507.16797}.'
    - 'Fault-tolerant flag-based non-transversal logical gates \cite{arxiv:2510.08402}.'

  decoders:
    - 'The size of the circuit extracting the syndrome depends on the weight of its corresponding stabilizer generator. Syndrome extraction circuits can be simulated efficiently using dedicated software (e.g., STIM \cite{arxiv:2103.02202}) and there are many general schemes for generating them \cite{arxiv:2408.01339} (see also \cite{arxiv:2402.04093}). Noise can be characterized without interrupting syndrome extraction \cite{arxiv:1710.03636}. Decoding of qubit stabilizer codes is an approximately optimal strategy for various quantum lights-out (QLO) games that can be played on the codes'' \hyperref[topic:encoder-respecting]{encoder-respecting form} \cite{arxiv:2411.14448}.'
    - 'DiVincenzo-Aliferis syndrome extraction circuits \cite{arxiv:quant-ph/0607047}.'
    - 'Greedy syndrome measurement schedule \cite{arxiv:2409.14283}.'
    - 'Dynamical weight reduction (DWR) scheme in which measurements of smaller-weight Paulis yield the outcome of a larger-weight Pauli via the use of ZX calculus and ancillary qubits \cite{arxiv:2410.12527}.'
    - 'Ancilla modes can be used for syndrome extraction instead of ancilla qubits \cite{arxiv:quant-ph/0511098}, and using two-component cat codes \cite{arxiv:1807.09334} yields fault-tolerant syndrome extraction circuits.'
    - 'Autonomous QEC protocol \cite{arxiv:quant-ph/0402017}.'
    - 'MPE decoding, i.e., the process of finding the most likely error, is \(NP\)-complete in the worst case \cite{arxiv:1009.1319,manual:{Kuo, Kao-Yueh, and Chung-Chin Lu. "On the hardness of decoding quantum stabilizer codes under the depolarizing channel." 2012 International Symposium on Information Theory and its Applications. IEEE, 2012.}}. If the noise model is such that the most likely error is the lowest-weight error, then ML decoding is called \textit{minimum-weight} decoding. Maximum-likelihood (ML) decoding (a.k.a.\ degenerate maximum-likelihood decoding), i.e., the process of finding the most likely error class (up to degeneracy of errors), is \(\#P\)-complete in the worst case \cite{arxiv:1310.3235}. Decoding a random qubit stabilizer code (i.e., the learning stabilizers with noise, or LSN, problem \cite{arxiv:2410.18953}) is at least as hard as decoding a random classical code at constant rate \cite{arxiv:2509.20697}.'
    - 'Incorporating faulty syndrome measurements can be done by performing spacetime decoding, i.e., using data from past rounds for decoding syndromes in any given round. If a decoder does not process syndrome data sufficiently quickly, it can lead to the \textit{backlog problem} \cite{arxiv:1302.3428}, slowing down the computation.'
    - 'Splitting decoders \cite{arxiv:2309.15354}.'
    - 'Trellis decoder, which builds a compact representation of the algebraic structure of the normalizer \(\mathsf{N(S)}\) \cite{arxiv:quant-ph/0512041}.'
    - 'Quantum extension of GRAND decoder \cite{arxiv:2208.02744}.'
    - 'Deep neural-network probabilistic decoder \cite{arxiv:1705.09334}.'
    - 'Generalized belief propagation (GBP) \cite{arxiv:2212.03214} based on a classical version \cite{manual:{J. S. Yedidia, W. T. Freeman, and Y. Weiss, Generalized belief propagation, in NIPS, Vol. 13 (2000) pp. 689â€“695.}}.'
    - 'Integer optimization decoder \cite{arxiv:2008.10206}.'
    - 'Autonomous Lindbladian based decoders for codes encoding a single logical qubit \cite{arxiv:2308.16233}.'
    - 'For codes encoding a single logical qubit, logical information can be extracted by single-qubit operations and classical communication \cite{arxiv:2308.14054}.'
    - 'Correlated decoding can improve performance of Clifford and \hyperref[topic:clifford]{non-Clifford} entangling gates \cite{arxiv:2403.03272}.'
    - 'Detector graphs \cite{arxiv:2103.02202,arxiv:2303.15933} and detector error models \cite{arxiv:2407.13826} can be used to design syndrome extraction circuits and logical measurements.'
    - 'Fault-tolerant constant-depth unencoder transforming logical states into physical states using single-qubit measurements \cite{arxiv:2408.06299}.'
    - 'Degenerate erasure decoder showing near ML decoding for various codes \cite{arxiv:2411.13509}.'
    - 'Tensor-network decoder for non-Markovian noise \cite{arxiv:2412.13739}.'
    - 'Delayed-erasure conversion decoder \cite{arxiv:2502.20558}.'
    - 'Trickle-down dissipative correction \cite{arxiv:2507.12534}.'

  fault_tolerance:
    - 'Gates in the \term{Clifford hierarchy} can be done using \textit{gate teleportation}, in which a gate can be obtained from a particular \textit{magic state} \cite{arxiv:quant-ph/9908010,arxiv:quant-ph/0002039}. Such protocols can be made fault tolerant with the help of magic-state distillation \cite{arxiv:quant-ph/0403025}. See review on magic-state distillation \cite{doi:10.1002/qua.24856}.'
    - 'Logical Bell measurements can be done transversally, and thus fault tolerantly, by performing bitwise Bell measurements for each pair of qubits (with each member of the pair taken from one of the two code blocks) and processing the result.'
    - 'With pieceable fault-tolerance, any \hyperref[topic:degeneracy]{non-degenerate} stabilizer code with a complete set of fault-tolerant single-qubit gates in the \hyperref[topic:clifford]{Clifford group} has a universal set of non-transversal fault-tolerant gates \cite{arxiv:1603.03948}.'
    - 'Shor error correction \cite{arxiv:quant-ph/9605011,arxiv:quant-ph/9605031} (see also Steane''s ancilla factory \cite{arxiv:quant-ph/9708021}), in which fault tolerance against syndrome extraction errors is ensured by simply repeating syndrome measurements. A modification uses adaptive measurements \cite{arxiv:2208.05601}.'
    - 'Generalization of Steane error correction stabilizer codes \cite[Sec. 3.6]{manual:{Yoder, Theodore., \emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}.'
    - 'Fault-tolerant error correction scheme by Knill (a.k.a. telecorrection \cite{arxiv:quant-ph/0601066}), which is based on teleportation \cite{arxiv:quant-ph/0410199,arxiv:quant-ph/0312190}. A variant of it has been termed the Fibonacci scheme \cite{arxiv:0809.5063}.'
    - 'Fault-tolerant error correction using flag qubits for codes satisfying certain conditions \cite{arxiv:1708.02246}.'
    - 'GHZ state distillation for Steane error correction \cite{arxiv:2109.06248}.'
    - 'Syndrome extraction using flag qubits and classical codes \cite{arxiv:2212.10738}.'
    - 'Fault-tolerant constant-depth unencoder transforming logical states into physical states using single-qubit measurements \cite{arxiv:2408.06299}.'
    - 'Post-selection based algorithm preparing magic state corresponding to arbitrary rotations \cite{arxiv:2303.17380}.'
    - '\hyperref[topic:code-switching]{Code switching} can be done using only transversal gates for qubit stabilizer codes \cite{arxiv:2409.13465}.'
    - 'Flag-Proxy Networks (FPNs) \cite{arxiv:2409.14283}.'
    - 'A logical Pauli can be \hyperref[topic:gauging-out]{gauged out} to yield a fault-tolerant measurement that requires a qubit overhead linear in the Pauli''s support \cite{arxiv:2410.02213}.'
    - 'Automated fault-tolerant circuit synthesis using boolean satisfiability \cite{arxiv:2501.05527}.'
    - 'Algorithm for fault-tolerant magic-state initialization \cite{arxiv:2501.10291}.'
    - 'Fault tolerance of qubit stabilizer codes has been formalized \cite{arxiv:2501.14380}.'
    - 'Fault-tolerant flag-based non-transversal logical gates \cite{arxiv:2510.08402}.'


  code_capacity_threshold:
    - 'Bounds on code capacity thresholds using ML decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model \cite{arxiv:quant-ph/0110143,arxiv:1208.2317,arxiv:1311.7688,arxiv:1809.10704}. The AQEC relative entropy is related to the resulting threshold \cite{arxiv:2312.16991}.'

  threshold:
    - 'Certain operations can be implemented in a fault-tolerant version \cite{arxiv:0806.0875,arxiv:0904.2143} of holonomic quantum computation \cite{arxiv:quant-ph/9904011}.'

# and various \textit{gadgets} (encoders, gates, measurements, decoders, etc.)

notes:
  - 'Introductions to stabilizer codes can be found in \cite{arxiv:quant-ph/9705052,arxiv:quant-ph/0304016,preset:PreskillNotes,doi:10.1002/9783527618637.ch1,arxiv:2507.07121}.'
  - 'Tables of bounds and examples of stabilizer codes for various \(n\) and \(k\), based on algorithms developed in Ref. \cite{doi:10.1007/978-3-540-37634-7_13}, are maintained by M. Grassl at this \href{https://codetables.markus-grassl.de/}{website}. A Magma implementation exists at this \href{https://magma.maths.usyd.edu.au/magma/handbook/text/1976}{website}.'
  - 'See Quantum Codes qubit stabilizer database, maintained by N. Aydin, P. Liu, and B. Yoshino \cite{arxiv:2106.12065,arxiv:2108.03567}, at this \href{https://quantumcodes.info/}{website}.'
  - 'See QEC database by S. Burton at this \href{https://qecdb.org/}{website}.'
  - 'Entanglement purification protocols with qubit stabilizer codes are related to quantum key distribution (QKD) \cite{arxiv:quant-ph/0209091}. There is a correspondence between stabilizer codes and bilocal Clifford entanglement distillation circuits \cite{arxiv:2303.11465}. Purification protocols using two-way classical channels can exceed the quantum Hamming and quantum Singleton bounds \cite{arxiv:quant-ph/0310097}.'
  - 'Qubit stabilizer codes can be used to estimate physical Pauli noise up to their \hyperref[topic:quantum-weight-enumerator]{pure distance} \cite{arxiv:2107.14252}, and logical Pauli noise for any correctable physical noise \cite{arxiv:2209.09267}.'
  - 'The stabilizer formalism has been gamified \cite{arxiv:2405.06795}.'
  - 'There is a relation between magic states and the onset of contextuality \cite{arxiv:1401.4174}.'
  - 'Codes can be found via genetic algorithms \cite{arxiv:2409.13017}.'
  - 'Stim Python software library for simulating and analyzing qubit stabilizer circuits \cite{arxiv:2103.02202,manual:{Craig Gidney. Stim. https://github.com/quantumlib/Stim, 2021.}}.'
  - 'PanQEC Python software library for simulating and visualizing qubit stabilizer codes \cite{arxiv:2211.02116,manual:{Eric Huang and Arthur Pesah. PanQEC. https://github.com/panqec/panqec, 2023.}}.'
  - 'QuantumSavory Julia software library that includes stabilizer formalism tools, symbolic manipulation, and a tool for drawing quantum circuits \cite{manual:{QuantumSavory. https://github.com/QuantumSavory, 2025.},doi:10.5281/zenodo.5208167}.'

relations:
  parents:
    - code_id: non_stabilizer
      detail: 'A stabilizer code with stabilizer group \(\mathsf{S}\) can be thought of as a USt with only the identity coset representative.
      Conversely, if the set of coset representatives of a USt form a linear binary code, then they can be absorbed into a stabilizer group that defines the USt.'
    - code_id: xp_stabilizer
      detail: 'XP stabilizer codes reduce to qubit stabilizer codes for \(N=2\).'
    - code_id: qubit_stabilizer_oaqecc
      detail: 'An OA qubit stabilizer code storing no classical information and admitting no gauge qubits is a qubit stabilizer code.'
    - code_id: qudit_stabilizer
      detail: 'Modular-qudit stabilizer codes for \(q=2\) correspond to qubit stabilizer codes.
      Modular-qudit stabilizer codes for prime-dimensional qudits \(q=p\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a \hyperref[topic:qudit-pauli]{modular-qudit Pauli group} with a unique number of generators.
      Conversely, qubit codes can be extended to modular-qudit codes by decorating appropriate generators with powers.
      For example, \([[4,2,2]]\) qubit code generators can be adjusted to \(ZZZZ\) and \(XX^{-1} XX^{-1}\).
      A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form  \cite{arxiv:1910.08122}.
      Various bounds exist on the distance of the resulting codes \cite{arxiv:2110.11510,arxiv:2110.15274}.'
    - code_id: galois_true_stabilizer
      detail: 'True Galois-qudit stabilizer codes for \(q=2\) correspond to qubit stabilizer codes.'
  cousins:
    - code_id: cws
      detail: 'CWS codes whose underlying classical code is a linear binary code are qubit stabilizer codes containing a cluster-state codeword \cite{arxiv:0708.1021,arxiv:1407.2777}.
      Since any stabilizer state is equivalent to a cluster state under a single-qubit \hyperref[topic:clifford]{Clifford circuit} \cite{arxiv:quant-ph/0308151}\cite[Appx. A]{arxiv:1910.00471}, any stabilizer code is similarly equivalent to a CWS code.'
    - code_id: binary_linear
      detail: |
        Qubit stabilizer codes are the closest quantum analogues of binary linear codes because addition modulo two corresponds to multiplication of stabilizers in the quantum case. 
        Any binary linear code can be thought of as a qubit stabilizer code with \(Z\)-type stabilizer generators \cite[Table I]{arxiv:quant-ph/0610088}\cite{arxiv:2507.05408}. 
        The stabilizer generators are extracted from rows of the parity-check matrix, while logical \(X\) Paulis correspond to rows of the generator matrix.
        States close to the equal superposition of all bitstrings within Hamming distance \(b\) of a binary linear code can be prepared efficiently \cite{arxiv:2404.16129}.
        Binary linear codes can be used for error-corrected entanglement distillation protocols \cite{arxiv:2408.06299}.
    - code_id: dual
      detail: 'Qubit stabilizer codes are in one-to-one correspondence with symplectic self-orthogonal binary linear codes of length \(2n\) via the \hyperref[topic:binary-symplectic-representation]{symplectic representation}.'
    - code_id: dual_additive
      detail: 'Qubit stabilizer codes are in one-to-one correspondence with trace-Hermitian self-orthogonal additive quaternary codes of length \(n\) via the \hyperref[topic:gf4-representation]{\(\mathbb{F}_4\) representation}.'
    - code_id: single_shot
      detail: 'Any stabilizer code can be single shot if sufficiently non-local high-weight stabilizer generators are used for syndrome measurements.  These can be obtained with a Gaussian elimination procedure \cite{arxiv:1805.09271}.'
    - code_id: t-designs
      detail: 'Stabilizer states on \(n\) qubits form 3-designs on complex projective spaces \(\mathbb{C}P^{2^n}\) \cite{arxiv:1510.02767}, while the \hyperref[topic:clifford]{Clifford group} is a unitary 3-design on \(U(2^n)\) \cite{arxiv:1510.02619,arxiv:1510.02769}. The \([[2m,2m-2,2]]\) code for \(2m\) being a multiple of four obstructs the Clifford group from being a 4-design \cite{arxiv:1609.08172}.'
    - code_id: unitary_design
      detail: 'Stabilizer states on \(n\) qubits form 3-designs on complex projective spaces \(\mathbb{C}P^{2^n}\) \cite{arxiv:1510.02767}, while the \hyperref[topic:clifford]{Clifford group} is a unitary 3-design on \(U(2^n)\) \cite{arxiv:1510.02619,arxiv:1510.02769}. The \([[2m,2m-2,2]]\) code for \(2m\) being a multiple of four obstructs the Clifford group from being a 4-design \cite{arxiv:1609.08172}.'
    # also in clifford_group
    - code_id: complex_projective
      detail: 'Stabilizer states on \(n\) qubits form 3-designs on complex projective spaces \(\mathbb{C}P^{2^n}\) \cite{arxiv:1510.02767}, while the \hyperref[topic:clifford]{Clifford group} is a unitary 3-design on \(U(2^n)\) \cite{arxiv:1510.02619,arxiv:1510.02769}.'
    - code_id: iceberg
      detail: 'The \([[2m,2m-2,2]]\) code for \(2m\) being a multiple of four obstructs the Clifford group from being a 4-design \cite{arxiv:1609.08172}.'
    - code_id: constant_excitation
      detail: 'Concatenating the dual-rail code with an \([[n,k,d]]\) stabilizer code yields an \([[2n,k,d]]\) constant-excitation code \cite{arxiv:2010.00538} that protects against \(d-1\) \hyperref[topic:ad]{AD} errors \cite{arxiv:1001.2356}.'
    - code_id: ampdamp
      detail: 'Concatenating the dual-rail code with an \([[n,k,d]]\) stabilizer code yields an \([[2n,k,d]]\) constant-excitation code \cite{arxiv:2010.00538} that protects against \(d-1\) \hyperref[topic:ad]{AD} errors \cite{arxiv:1001.2356}.'
    - code_id: two-legged-cat
      detail: 'Ancilla modes can be used for syndrome extraction instead of ancilla qubits \cite{arxiv:quant-ph/0511098}, and using two-component cat codes \cite{arxiv:1807.09334} yields fault-tolerant syndrome extraction circuits.'
    - code_id: projective
      detail: '\([[n,k,d]]\) qubit stabilizer codes with no weight-one stabilizers are equivalent to particular "quantum" sets of lines in projective space \(PG(n-k-1,2)\) \cite[Thm. 3.7]{arXiv:2007.05992}\cite{manual:{Glynn, David G., T. Aaron Gulliver, Johannes G. Maks, and Manish K. Gupta. "The geometry of additive quantum codes." submitted to Springer-Verlag (2004).},arxiv:2107.11281}. This equivalence is stated in the case of \hyperref[topic:quantum-weight-enumerator]{pure} qubit stabilizer codes with distance two or greater in \cite[Thm. 2.6]{doi:10.2140/iig.2008.6.53}.'
    - code_id: holographic
      detail: 'Qubit stabilizer states can be interpreted as states that are preparable using the Euclidean path integral in 3D Chern-Simons theory, defined on manifolds that are toy models of AdS/CFT wormholes \cite{arxiv:1611.01516,arxiv:2510.15067}.'
    - code_id: topological_abelian
      detail: 'Qubit stabilizer states can be interpreted as states that are preparable using the Euclidean path integral in 3D Chern-Simons theory, defined on manifolds that are toy models of AdS/CFT wormholes \cite{arxiv:1611.01516,arxiv:2510.15067}.'


# Begin Entry Meta Information
_meta:
  # Change log - most recent first
  changelog:
    - user_id: VictorVAlbert
      date: '2022-09-28'
    - user_id: VictorVAlbert
      date: '2022-05-19'
    - user_id: VictorVAlbert
      date: '2022-02-16'
    - user_id: QingfengKeeWang
      date: '2021-12-07'
    - user_id: LaneGGunderman
      date: '2022-02-04'
    - user_id: LeonidPryadko
      date: '2021-11-02'
    - user_id: DanielGottesman
      date: '2021-11-02'
    - user_id: VictorVAlbert
      date: '2021-11-02'
